%tested 8/31/00% solvePos.m	(actual file name: solvePos.m)%% < FOUR OR MORE SATELLITE SOLUTION >%% this function calculates the position of the observation station%% input: 'ephem' matrix which rows contain orbital ephemerides for%		a given satellite%					< see formatData.m for description >%			'pseudoR' vector which contains pseudo-ranges (meters) for%		the satellites being used in the navigational solution%						[ pr pr pr pr ]%			'guess' vector containing an initial position guess in%		ECEF coordinates%			'gpsTime' variable which contains the GPS time a%		navigational solution will be found for%% output: 'posOBS' matrix which contains a GPS time (seconds), ECEF%		coordiates of the navigational solution (meters) and the%		receiver clock offset at that GPS time (seconds)%						[ GPS time ECEFx ECEFy ECEFz recCO ]%% < FOUR OR MORE SATELLITE SOLUTION >%function posOBS = solveposod(ephem,pseudoR,guess,gpsTime)% define physical constantsconstant;% determine number of satellitesnumSats = size(pseudoR,1);% initialize real range to satellitesrange = zeros(numSats,1);% solve for position iteratively until solution is within an% acceptable errorstop = 0;while (stop == 0)    % create guess matrix    guessmatrix = zeros(numSats, 3);    for i = 1:numSats        guessmatrix(i,:) = guess;    end    % calculate difference between time of reception and    % transmission in	order to shift satellites back to where    % they were at transmission    tcorr = range ./ c;    % calculate 'satXYZ' based at time 'GPStime' - 'tcorr' for    % each satellite; then, rotate backwards by Earth's rotation    % during that time    satXYZ = findsat(ephem,gpsTime - tcorr);    satX = satXYZ(:,3);    satY = satXYZ(:,4);    delX = satY .* tcorr .* OmegaE;    delY = satX .* tcorr .* OmegaE;    satXYZ = satXYZ(:,3:5) + [ delX -delY zeros(numSats,1) ];    % calculate satellite ranges 'range' from guess to satellites    delXYZ = satXYZ - guessmatrix;    range = sqrt(sum((delXYZ.^2),2));    %  form the vector 'l' and the matrix 'A'    l = pseudoR - range;    cmatrix = ones(numSats,1);    pmatrix = range * ones(1,3);    A = delXYZ ./ pmatrix;    A = -[ A cmatrix ];    % solve for  'deltaPos' which is contains dx, dy, dz, and  dt    deltaPOS = A \ l;    % calculate 'obsPos' by adding 'deltaPos' to the current guess    obsPos = [ guess 0 ] + deltaPOS';    obsPos(4) = obsPos(4)/c;    % check to see if the initial guess and the computed result is    % "close enough"; if it is, then stop the iteration by setting the    % 'stop' flag to 1; else, set the new initial guess equal to the    % last computed value, and iterate again    if ((abs(obsPos(1:3) - guess)) < 1e-6)        stop = 1;    end    guess = obsPos(1:3);end% create the output matrix 'posOBS' and returnposOBS(1) = gpsTime;posOBS(2:5) = obsPos;return;